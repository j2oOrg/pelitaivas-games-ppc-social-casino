<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Pelitaivas | Play</title>
  <meta name="description" content="Play a free online game directly on pelitaivas.games in-browser with quick rules and no real-money play.">
  <meta name="keywords" content="play games online, free in-browser games, arcade challenge, quick play">
  <meta name="author" content="Pelitaivas">
  <meta name="robots" content="index, follow">
  <meta property="og:type" content="website">
  <meta property="og:site_name" content="Pelitaivas">
  <meta property="og:title" content="Pelitaivas | Play">
  <meta property="og:description" content="Play a free online game directly on pelitaivas.games in-browser with quick rules and no real-money play.">
  <meta property="og:url" content="https://pelitaivas.games/play.html">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Pelitaivas | Play">
  <meta name="twitter:description" content="Play a free online game directly on pelitaivas.games in-browser with quick rules and no real-money play.">
  <link rel="canonical" href="https://pelitaivas.games/play.html">
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700;800&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #f7f9ff;
      --surface: #ffffff;
      --ink: #121421;
      --muted: #4f5568;
      --accent: #ff5a5f;
      --accent-2: #1fc9ff;
      --accent-3: #b8ff3d;
      --accent-4: #ffd23a;
      --edge: #dde6ff;
      --shadow: 0 22px 50px rgba(18, 20, 33, 0.12);
      --bento-glow: linear-gradient(135deg, rgba(255, 90, 95, 0.18), rgba(31, 201, 255, 0.2) 50%, rgba(255, 210, 58, 0.22));
    }
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      font-family: "Poppins", sans-serif;
      color: var(--ink);
      background: radial-gradient(circle at 12% 10%, rgba(255, 90, 95, 0.28), transparent 55%),
        radial-gradient(circle at 85% 15%, rgba(31, 201, 255, 0.28), transparent 48%),
        linear-gradient(135deg, #fff5f1, #f1fbff);
      min-height: 100vh;
      position: relative;
      overflow-x: hidden;
    }
    body::before,
    body::after {
      content: "";
      position: fixed;
      border-radius: 999px;
      opacity: 0.35;
      z-index: 0;
      pointer-events: none;
    }
    body::before {
      width: 320px;
      height: 320px;
      background: radial-gradient(circle, rgba(255, 90, 95, 0.75), transparent 70%);
      top: -140px;
      left: -120px;
    }
    body::after {
      width: 260px;
      height: 260px;
      background: radial-gradient(circle, rgba(31, 201, 255, 0.7), transparent 70%);
      bottom: -120px;
      right: -100px;
    }
    a {
      color: inherit;
      text-decoration: none;
    }
    main {
      padding: 32px 16px 80px;
      max-width: 1100px;
      margin: 0 auto;
      position: relative;
      z-index: 1;
    }
    main > section {
      opacity: 0;
      transform: translateY(16px);
      animation: rise 0.7s ease forwards;
      background: var(--surface);
      border: 1px solid var(--edge);
      border-radius: 28px;
      padding: 24px;
      box-shadow: var(--shadow);
    }
    main > section:nth-of-type(1) { animation-delay: 0.05s; }
    main > section:nth-of-type(2) { animation-delay: 0.12s; }
    main > section:nth-of-type(3) { animation-delay: 0.18s; }
    main > section:nth-of-type(4) { animation-delay: 0.24s; }
    main > section:nth-of-type(5) { animation-delay: 0.3s; }
    h1, h2, h3, h4 {
      font-family: "Poppins", sans-serif;
      margin: 0 0 12px;
    }
    p {
      margin: 0 0 12px;
    }
    :focus-visible {
      outline: 3px solid var(--accent-2);
      outline-offset: 2px;
    }
    [hidden] {
      display: none !important;
    }

    .site-head-p4k2v9 {
      position: sticky;
      top: 0;
      z-index: 10;
      background: rgba(255, 255, 255, 0.92);
      border-bottom: 1px solid var(--edge);
      backdrop-filter: blur(8px);
    }
    .head-inner-p8m5n1 {
      max-width: 1100px;
      margin: 0 auto;
      padding: 14px 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
      flex-wrap: wrap;
    }
    .brand-mark-p1d7x3 {
      font-size: 1.3rem;
      font-weight: 700;
      letter-spacing: 0.5px;
    }
    .head-inner-p8m5n1 nav {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }
    .head-inner-p8m5n1 nav a {
      padding: 8px 12px;
      border-radius: 999px;
      background: rgba(31, 201, 255, 0.22);
      border: 1px solid rgba(31, 201, 255, 0.35);
      box-shadow: 0 10px 18px rgba(18, 20, 33, 0.08);
      transition: transform 0.2s ease, background 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
    }
    .head-inner-p8m5n1 nav a:hover {
      background: rgba(31, 201, 255, 0.35);
      box-shadow: 0 14px 22px rgba(18, 20, 33, 0.14);
      transform: translateY(-1px);
    }
    .head-note-p6r9c2 {
      font-size: 0.8rem;
      padding: 6px 12px;
      border-radius: 999px;
      background: linear-gradient(135deg, rgba(255, 90, 95, 0.28), rgba(255, 210, 58, 0.35));
      border: 1px solid rgba(255, 90, 95, 0.35);
      color: #6b1f25;
      white-space: nowrap;
    }

    .play-wrap-p3t5h7 {
      margin-top: 20px;
      padding: 28px;
      background: var(--bento-glow);
      border: 1px solid var(--edge);
      border-radius: 24px;
      box-shadow: var(--shadow);
      display: grid;
      gap: 20px;
    }
    .play-wrap-p3t5h7 small {
      text-transform: uppercase;
      letter-spacing: 2px;
      font-size: 0.7rem;
      color: var(--muted);
    }
    .play-wrap-p3t5h7 p {
      color: var(--muted);
    }
    .play-wrap-p3t5h7 ul {
      list-style: none;
      margin: 12px 0 0;
      padding: 0;
      display: grid;
      gap: 10px;
    }
    .play-wrap-p3t5h7 li {
      background: rgba(255, 255, 255, 0.8);
      border: 1px solid var(--edge);
      border-radius: 999px;
      padding: 8px 12px;
      font-size: 0.9rem;
      color: var(--muted);
    }

    .compliance-wrap-p8x3q5 {
      margin-top: 20px;
      padding: 16px;
      border-radius: 18px;
      border: 1px solid rgba(31, 201, 255, 0.35);
      background: rgba(31, 201, 255, 0.08);
      color: var(--muted);
    }
    .compliance-wrap-p8x3q5 h2 {
      color: var(--ink);
      margin-bottom: 8px;
      margin-top: 0;
    }
    .compliance-wrap-p8x3q5 ul {
      margin: 0;
      padding-left: 20px;
      display: grid;
      gap: 8px;
    }

    .preview-wrap-p9q2f6 {
      margin-top: 32px;
      padding: 20px;
      background: var(--surface);
      border: 1px solid var(--edge);
      border-radius: 22px;
      display: grid;
      gap: 16px;
      align-items: center;
      box-shadow: var(--shadow);
    }
    .preview-wrap-p9q2f6 p {
      color: var(--muted);
    }
    .preview-wrap-p9q2f6 img {
      width: 100%;
      height: 120px;
      object-fit: cover;
      border-radius: 16px;
      border: 1px solid var(--edge);
    }

    .frame-wrap-p2s8j4 {
      margin-top: 32px;
      padding: 20px;
      background: #fff;
      border: 1px solid var(--edge);
      border-radius: 22px;
      display: grid;
      gap: 16px;
      box-shadow: var(--shadow);
    }
    .frame-wrap-p2s8j4 h2 {
      margin: 0;
      font-size: 1.2rem;
      color: var(--ink);
    }
    .game-status-box-p2s8j4 {
      background: #fff3c9;
      border: 1px dashed rgba(255, 90, 95, 0.55);
      border-radius: 16px;
      padding: 10px 14px;
      color: #6b1f25;
      font-weight: 600;
    }
    .game-hud-p2s8j4 {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 10px;
      padding: 10px;
      border: 1px solid var(--edge);
      border-radius: 14px;
      background: #f8fbff;
      font-size: 0.95rem;
      color: var(--muted);
      text-align: center;
    }
    .game-stage-p2s8j4 {
      min-height: 430px;
      border: 1px solid var(--edge);
      border-radius: 18px;
      background: linear-gradient(180deg, #f8fbff 0%, #edf6ff 100%);
      position: relative;
      overflow: hidden;
      box-shadow: var(--shadow);
      user-select: none;
    }
    .game-message-p2s8j4 {
      min-height: 20px;
      margin: 0;
      color: var(--muted);
      text-align: center;
    }
    .neon-target-p2s8j4 {
      position: absolute;
      width: 58px;
      height: 58px;
      border-radius: 999px;
      top: -70px;
      border: 1px solid #fff;
      display: grid;
      place-items: center;
      font-size: 24px;
      color: #fff;
      cursor: pointer;
      background: radial-gradient(circle at 30% 30%, #fff, #ff9ca0);
      box-shadow: 0 10px 24px rgba(255, 90, 95, 0.35);
      animation: game-drop var(--neon-drop-duration) linear forwards;
      pointer-events: all;
    }
    .neon-target-p2s8j4:active {
      transform: translateY(2px);
    }
    .prism-board-p2s8j4 {
      position: absolute;
      inset: 8px;
      display: grid;
      place-items: center;
      gap: 12px;
      grid-template-columns: repeat(2, minmax(100px, 1fr));
      grid-template-rows: repeat(2, minmax(100px, 1fr));
    }
    .prism-btn-p2s8j4 {
      width: 100%;
      aspect-ratio: 1 / 1;
      border: 1px solid var(--edge);
      border-radius: 20px;
      color: #fff;
      font-weight: 700;
      cursor: pointer;
      opacity: 0.9;
      transition: transform 0.15s ease, box-shadow 0.2s ease, opacity 0.2s ease;
      position: relative;
    }
    .prism-btn-p2s8j4.active {
      opacity: 1;
      transform: scale(0.98);
      box-shadow: inset 0 0 24px rgba(255, 255, 255, 0.4);
    }
    .treasure-orb-p2s8j4 {
      position: absolute;
      width: 46px;
      height: 46px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.9);
      background: radial-gradient(circle at 30% 30%, #fff, #8af8ff);
      color: #2a5d6e;
      font-weight: 700;
      display: grid;
      place-items: center;
      cursor: pointer;
      animation: orb-fade 2.7s linear forwards;
    }
    .drift-stage-p2s8j4 {
      position: absolute;
      inset: 8px;
      background-image: repeating-linear-gradient(
        90deg,
        transparent,
        transparent 31px,
        rgba(255, 90, 95, 0.15) 32px,
        rgba(31, 201, 255, 0.15) 33px,
        transparent 34px
      );
    }
    .drift-player-p2s8j4 {
      position: absolute;
      width: 36px;
      height: 36px;
      border-radius: 6px;
      background: linear-gradient(135deg, #ff5a5f, #ff8d92);
      border: 2px solid #fff;
      bottom: 12px;
      box-shadow: 0 6px 16px rgba(255, 90, 95, 0.36);
    }
    .drift-obstacle-p2s8j4 {
      position: absolute;
      width: 34px;
      height: 34px;
      border-radius: 50%;
      background: linear-gradient(135deg, #ffd23a, #ffb900);
      border: 1px solid #fff;
      top: -42px;
    }
    .neon-boost-p2s8j4 {
      position: absolute;
      inset: 0;
      border: 1px dashed rgba(31, 201, 255, 0.35);
      border-radius: 18px;
      pointer-events: none;
      opacity: 0.5;
      animation: pulse-arcade 1.8s ease-in-out infinite;
    }
    @keyframes game-drop {
      to {
        transform: translateY(520px);
      }
    }
    @keyframes orb-fade {
      from { opacity: 1; transform: scale(0.85); }
      to { opacity: 0; transform: scale(1.05); }
    }
    @keyframes pulse-arcade {
      from { opacity: 0.42; }
      to { opacity: 0.12; }
    }
    .cta-row-p7u1l5 {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
    }
    .cta-row-p7u1l5 button {
      padding: 10px 16px;
      border-radius: 999px;
      border: none;
      background: var(--accent-2);
      color: #fff;
      font-weight: 600;
      cursor: pointer;
    }
    .cta-row-p7u1l5 a {
      padding: 10px 16px;
      border-radius: 999px;
      border: 1px solid var(--accent-2);
      color: var(--accent-2);
      font-weight: 600;
    }

    .balance-wrap-p4k1q7 header p {
      color: var(--muted);
      max-width: 640px;
    }
    .balance-wrap-p4k1q7 ul {
      margin: 16px 0 0;
      padding-left: 20px;
      color: var(--muted);
      display: grid;
      gap: 8px;
    }
    .balance-wrap-p4k1q7 li {
      line-height: 1.5;
    }

    .tips-wrap-j3k8q1 header p {
      color: var(--muted);
      max-width: 640px;
    }
    .tips-wrap-j3k8q1 ul {
      margin: 16px 0 0;
      padding-left: 20px;
      color: var(--muted);
      display: grid;
      gap: 8px;
    }
    .tips-wrap-j3k8q1 li {
      line-height: 1.5;
    }

    .site-foot-p0w6z2 {
      margin-top: 60px;
      border-top: 1px solid var(--edge);
      background: rgba(255, 255, 255, 0.9);
      position: relative;
      z-index: 1;
    }
    .foot-inner-p8y2g9 {
      max-width: 1100px;
      margin: 0 auto;
      padding: 32px 16px;
      display: grid;
      gap: 24px;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    }
    .foot-inner-p8y2g9 p {
      color: var(--muted);
    }
    .foot-inner-p8y2g9 nav {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .foot-inner-p8y2g9 nav a {
      color: var(--muted);
    }
    .foot-inner-p8y2g9 nav a:hover {
      color: var(--accent);
    }
    .foot-bar-p1c7m4 {
      border-top: 1px dashed var(--edge);
      padding: 16px;
      max-width: 1100px;
      margin: 0 auto;
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      justify-content: space-between;
      color: var(--muted);
      font-size: 0.9rem;
    }

    .cookie-bar-p6n3x8 {
      position: fixed;
      bottom: 16px;
      left: 16px;
      right: 16px;
      background: #ffffff;
      border: 1px solid var(--edge);
      border-radius: 16px;
      padding: 12px 16px;
      box-shadow: var(--shadow);
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
      justify-content: space-between;
      z-index: 20;
    }
    .cookie-bar-p6n3x8 p {
      margin: 0;
      color: var(--muted);
    }
    .cookie-bar-p6n3x8 button {
      border-radius: 999px;
      padding: 8px 14px;
      border: 1px solid var(--accent-2);
      background: var(--accent-2);
      color: #fff;
      cursor: pointer;
    }
    .cookie-bar-p6n3x8 button:last-child {
      background: transparent;
      color: var(--accent-2);
    }

    @keyframes rise {
      from {
        opacity: 0;
        transform: translateY(16px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    @media (min-width: 900px) {
      .play-wrap-p3t5h7 {
        grid-template-columns: 1.2fr 0.8fr;
        align-items: center;
      }
      .preview-wrap-p9q2f6 {
        grid-template-columns: 0.9fr 1.1fr;
      }
    }
    @media (max-width: 720px) {
      .head-inner-p8m5n1 {
        justify-content: center;
      }
      .head-note-p6r9c2 {
        order: 3;
      }
    }
    @media (prefers-reduced-motion: reduce) {
      main > section {
        animation: none;
        opacity: 1;
        transform: none;
      }
    }
  </style>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=AW-17829629101"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'AW-17829629101');
</script>
</head>
<body>
  <header class="site-head-p4k2v9">
    <div class="head-inner-p8m5n1">
      <a class="brand-mark-p1d7x3" href="index.html" aria-label="Pelitaivas home">Pelitaivas</a>
      <nav aria-label="Primary">
        <a href="index.html">Home</a>
        <a href="games.html">Games</a>
        <a href="play.html">Play</a>
        <a href="about.html">About</a>
        <a href="contact.html">Contact</a>
      </nav>
      <div class="head-note-p6r9c2">18+ only | Free-play</div>
    </div>
  </header>

  <main>
    <section class="play-wrap-p3t5h7">
      <div>
        <small data-game-tag>Main Stage</small>
        <h1 data-game-title>Neon Dash</h1>
        <p data-game-desc>Choose a title from the catalog and start a short free-play round.</p>
        <ul data-game-highlights>
          <li>No real-money features, no prizes, no accounts.</li>
          <li>Simple controls for both desktop and touch.</li>
          <li>Play sessions are short by design.</li>
        </ul>
      </div>
      <div>
        <h2>Good to know</h2>
        <ul data-game-meta>
          <li>gaming website free-play only, no real money, no prizes, no cash-out.</li>
          <li>For adults 18+.</li>
          <li>Play as long or short as you like.</li>
        </ul>
      </div>
    </section>

    <section class="compliance-wrap-p8x3q5">
      <h2>No gambling offered</h2>
      <ul>
        <li>This page is for entertainment games only and does not include gambling.</li>
        <li>No betting, no wagering, and no real-money rewards are available.</li>
        <li>There are no prizes, no cash-out, and no progress to chase.</li>
      </ul>
    </section>

    <section class="preview-wrap-p9q2f6">
      <div>
        <h2>Preview</h2>
        <p data-game-quick-tip>A quick look at the game before you start.</p>
      </div>
      <img src="images/game-night-word-png-grunge-gray-font-transparent-background.jpg" alt="Game preview placeholder" loading="lazy" data-game-preview>
    </section>

    <section class="frame-wrap-p2s8j4">
      <h2>Game room</h2>
      <div class="game-status-box-p2s8j4" data-game-status>Ready for your game.</div>
      <div class="game-hud-p2s8j4">
        <strong data-game-score>Score: 0</strong>
        <span data-game-lives>Lives: 3</span>
        <span data-game-timer>Ready</span>
      </div>
      <div class="game-stage-p2s8j4" data-game-stage tabindex="0" role="application" aria-label="Game stage"></div>
      <p class="game-message-p2s8j4" data-game-message></p>
      <div class="cta-row-p7u1l5">
        <button type="button" data-game-start>Start game</button>
        <button type="button" data-game-random>Pick another game</button>
        <a href="games.html">Back to catalog</a>
      </div>
    </section>

    <section class="balance-wrap-p4k1q7">
      <header>
        <h2>Responsible play</h2>
        <p>This is meant to be a light break, not a long session. A quick plan before you start keeps it that way.</p>
      </header>
      <p>Set a small time limit, even if it is just ten minutes. When the timer is up, close the tab and move on to whatever is next.</p>
      <ul>
        <li>Take breaks if you feel distracted, tired, or restless.</li>
        <li>Keep the volume low in shared spaces so it stays in the background.</li>
        <li>Step away if it stops being fun. Nothing is saved.</li>
      </ul>
      <p>We built this for short sessions, and it works best when you treat it that way.</p>
    </section>

    <section class="tips-wrap-j3k8q1">
      <header>
        <h2>How to play now</h2>
        <p data-game-howto>Follow the game steps below and start when ready.</p>
      </header>
      <ul data-game-instructions>
        <li>Press Start when a round is loaded.</li>
        <li>Keep an eye on the timer and live score.</li>
        <li>Switch to another game at any time.</li>
      </ul>
      <p>Nothing is saved between sessions, so you can close the tab whenever you are done.</p>
    </section>
  </main>

  <footer class="site-foot-p0w6z2">
    <div class="foot-inner-p8y2g9">
      <div>
        <h3>Pelitaivas</h3>
        <p>A gaming website lounge for adults who enjoy game-inspired visuals without real-money play.</p>
      </div>
      <div>
        <h4>Explore</h4>
        <nav aria-label="Footer">
          <a href="games.html">Games</a>
          <a href="play.html">Play</a>
          <a href="about.html">About</a>
          <a href="contact.html">Contact</a>
          <a href="terms.html">Terms</a>
          <a href="policy.html">Privacy</a>
        </nav>
      </div>
    </div>
    <div class="foot-bar-p1c7m4">
      <span>18+ only. Free-play for entertainment, no real money, no prizes, no cash-out.</span>
      <span>Questions? Email hello@Pelitaivas.com</span>
    </div>
  </footer>

  <div class="cookie-bar-p6n3x8" data-cookie-banner>
    <p>We use cookies to remember your choice and keep the lounge running smoothly.</p>
    <div>
      <button type="button" data-cookie-accept>Accept</button>
      <button type="button" data-cookie-decline>Decline</button>
    </div>
  </div>

  <script>
    (function() {
      // UI helpers for cookie consent and game selection.

      // Cookie banner: store the choice and hide it after selection.
      const banner = document.querySelector('[data-cookie-banner]');
      const accepted = (() => {
        try { return localStorage.getItem('pp_cookie_choice'); } catch (err) { return null; }
      })();
      if (banner && accepted) {
        banner.setAttribute('hidden', '');
      }
      const saveChoice = (value) => {
        try { localStorage.setItem('pp_cookie_choice', value); } catch (err) {}
        if (banner) {
          banner.setAttribute('hidden', '');
        }
      };
      const acceptBtn = document.querySelector('[data-cookie-accept]');
      const declineBtn = document.querySelector('[data-cookie-decline]');
      if (acceptBtn) {
        acceptBtn.addEventListener('click', () => saveChoice('accepted'));
      }
      if (declineBtn) {
        declineBtn.addEventListener('click', () => saveChoice('declined'));
      }

      // Game loader: choose the in-page game from the URL or at random, then run it.
      const gameList = [
        {
          id: 'neon-dash',
          name: 'Neon Dash',
          tag: 'Action',
          desc: 'Tap glowing targets before they disappear and keep your score moving.',
          quickTip: 'Watch the stage and click targets as they come down.',
          highlights: [
            'No real-money play, no prizes, no cash-out.',
            'Fast rounds with clear visual timing cues.',
            'Great for quick, short sessions.'
          ],
          instructions: [
            'Press Start game.',
            'Click each neon target before it reaches the bottom.',
            'Avoid too many misses, or lives drop to zero.'
          ],
          howTo: 'Neon Dash is a fast reaction game. You lose a life each time a target escapes.'
        },
        {
          id: 'puzzle-prism',
          name: 'Puzzle Prism',
          tag: 'Focus',
          desc: 'Watch the color sequence, then repeat it correctly.',
          quickTip: 'Focus your attention and memorize the full sequence before tapping.',
          timeLimit: 60,
          lives: 4,
          highlights: [
            'Four colored pads with clear flash cues.',
            'Each level adds one more step to the sequence.',
            'Accuracy matters more than speed.'
          ],
          instructions: [
            'Press Start game.',
            'Observe each color pattern carefully.',
            'Tap the colors in the same order to continue.'
          ],
          howTo: 'Each successful sequence gives points and adds one step. Mistakes cost a life.'
        },
        {
          id: 'treasure-orbit',
          name: 'Treasure Orbit',
          tag: 'Collector',
          desc: 'Collect floating treasure orbs before they disappear from the board.',
          quickTip: 'Prioritize closest orbs and keep your cursor moving.',
          timeLimit: 60,
          lives: 3,
          highlights: [
            'Fast-spawning targets appear across the board.',
            'Each captured orb gives points.',
            'Misses reduce remaining lives.'
          ],
          instructions: [
            'Press Start game.',
            'Click each orb as it appears.',
            'Miss too many orbs and the board ends your round.'
          ],
          howTo: 'Treasure Orbit rewards fast movement and accurate clicks in a short time window.'
        },
        {
          id: 'pixel-drift',
          name: 'Pixel Drift',
          tag: 'Arcade',
          desc: 'Move your pixel ship across lanes and avoid incoming obstacles.',
          quickTip: 'Use touch zones or arrow keys to change lanes.',
          timeLimit: 60,
          lives: 4,
          highlights: [
            'Avoid incoming objects for as long as possible.',
            'Every pass adds points.',
            'Use left/right control at the right moments.'
          ],
          instructions: [
            'Press Start game.',
            'Keep your ship clear of falling obstacles.',
            'Press left/right by touching the stage, or use arrow keys.'
          ],
          howTo: 'Pixel Drift is a lane dodge game; survival is the objective.'
        }
      ];

      const titleEl = document.querySelector('[data-game-title]');
      const descEl = document.querySelector('[data-game-desc]');
      const tagEl = document.querySelector('[data-game-tag]');
      const stageEl = document.querySelector('[data-game-stage]');
      const quickTipEl = document.querySelector('[data-game-quick-tip]');
      const statusEl = document.querySelector('[data-game-status]');
      const scoreEl = document.querySelector('[data-game-score]');
      const livesEl = document.querySelector('[data-game-lives]');
      const timerEl = document.querySelector('[data-game-timer]');
      const messageEl = document.querySelector('[data-game-message]');
      const howToEl = document.querySelector('[data-game-howto]');
      const instructionsEl = document.querySelector('[data-game-instructions]');
      const highlightsEl = document.querySelector('[data-game-highlights]');
      const metaEl = document.querySelector('[data-game-meta]');
      const previewEl = document.querySelector('[data-game-preview]');
      const startBtn = document.querySelector('[data-game-start]');
      const randomBtn = document.querySelector('[data-game-random]');

      const getGameById = (value) => gameList.find((game) => game.id === value);
      const clearList = (el) => {
        if (!el) return;
        el.innerHTML = '';
      };
      const populateList = (el, values) => {
        clearList(el);
        (values || []).forEach((value) => {
          const item = document.createElement('li');
          item.textContent = value;
          el.append(item);
        });
      };
      const renderHUD = (state) => {
        if (!state) return;
        if (scoreEl) {
          scoreEl.textContent = `Score: ${state.score}`;
        }
        if (livesEl) {
          const base = state.lives != null ? state.lives : 0;
          livesEl.textContent = `Lives: ${base}`;
        }
        if (timerEl) {
          if (state.timeLeft == null) {
            timerEl.textContent = 'Time: --';
          } else {
            timerEl.textContent = `Time: ${state.timeLeft}s`;
          }
        }
      };
      const setMessage = (text) => {
        if (messageEl) {
          messageEl.textContent = text || '';
        }
      };
      const showMessage = (state, text, timeoutMs = 900) => {
        if (!state || !text) return;
        setMessage(text);
        const timer = setTimeout(() => {
          if (state.running && state === currentState) {
            setMessage('');
          }
        }, timeoutMs);
        state.cleanups.push(() => clearTimeout(timer));
      };
      const clearState = (state) => {
        if (!state) return;
        state.running = false;
        while (state.cleanups.length > 0) {
          const fn = state.cleanups.pop();
          try {
            fn();
          } catch (err) {}
        }
        if (state.stageEl) {
          state.stageEl.innerHTML = '';
          const hint = document.createElement('div');
          hint.textContent = 'Press Start to begin.';
          hint.style.cssText = 'position:absolute; inset: 0; display:grid; place-items:center; color: var(--muted); font-size: 0.95rem; text-align:center; padding: 14px;';
          state.stageEl.appendChild(hint);
        }
      };
      const finishGame = (state, text) => {
        if (!state || !state.running) return;
        clearState(state);
        setMessage(text || 'Round complete. Press Start to play again.');
        if (statusEl) {
          statusEl.textContent = text || 'Round complete.';
        }
        if (startBtn) {
          startBtn.textContent = 'Start game';
        }
      };
      const countdown = (state) => {
        state.timeLeft = state.timeLimit;
        renderHUD(state);
        const interval = setInterval(() => {
          if (!state.running) return;
          state.timeLeft -= 1;
          renderHUD(state);
          if (state.timeLeft <= 0) {
            finishGame(state, 'Time up! Good run.');
          }
        }, 1000);
        state.cleanups.push(() => clearInterval(interval));
      };
      const setGame = (game, updateUrl = true) => {
        clearState(currentState);
        currentGame = game;
        if (titleEl) titleEl.textContent = game.name;
        if (descEl) descEl.textContent = game.desc;
        if (tagEl) tagEl.textContent = game.tag;
        if (quickTipEl) quickTipEl.textContent = game.quickTip;
        if (howToEl) howToEl.textContent = game.howTo;
        populateList(instructionsEl, game.instructions);
        populateList(highlightsEl, game.highlights);
        populateList(metaEl, [
          game.howTo,
          'for adults 18+ only',
          '18+ notice: 18+ only.'
        ]);
        if (previewEl) {
          previewEl.alt = `${game.name} preview`;
        }
        if (statusEl) {
          statusEl.textContent = `${game.name} ready. Press Start game.`;
        }
        setMessage('Press Start game.');
        const timer = Math.min(90, Math.max(30, game.timeLimit || 40));
        if (stageEl) {
          stageEl.innerHTML = '';
          const hint = document.createElement('div');
          hint.textContent = `Ready: ${game.name}. ${timer}s each round.`;
          hint.style.cssText = 'position:absolute; inset: 0; display:grid; place-items:center; color: var(--muted); text-align:center; padding: 14px;';
          stageEl.appendChild(hint);
        }
        if (scoreEl) {
          scoreEl.textContent = 'Score: 0';
        }
        if (livesEl) {
          livesEl.textContent = `Lives: ${game.lives || 3}`;
        }
        if (timerEl) {
          timerEl.textContent = `Time: ${timer}s`;
        }
        if (startBtn) {
          startBtn.textContent = 'Start game';
        }
        if (updateUrl) {
          try {
            const url = new URL(window.location.href);
            url.searchParams.set('game', game.id);
            window.history.replaceState({}, '', url);
          } catch (err) {}
        }
      };
      const runNeonDash = (state) => {
        const spawnTarget = () => {
          if (!state.running) return;
          const target = document.createElement('button');
          const fallTime = 900 + Math.floor(Math.random() * 800);
          const x = 8 + Math.floor(Math.random() * 84);

          target.type = 'button';
          target.className = 'neon-target-p2s8j4';
          target.textContent = '⚡';
          target.style.left = `${x}%`;
          target.style.setProperty('--neon-drop-duration', `${fallTime}ms`);
          target.style.animationDuration = `${fallTime}ms`;
          target.style.pointerEvents = 'auto';

          let hit = false;
          const timeout = setTimeout(() => {
            if (!state.running || hit) return;
            target.remove();
            state.lives -= 1;
            renderHUD(state);
            showMessage(state, `Missed one target. Lives ${state.lives}.`, 800);
            if (state.lives <= 0) {
              finishGame(state, 'You ran out of lives in Neon Dash.');
            }
          }, fallTime + 20);
          state.cleanups.push(() => clearTimeout(timeout));

          const tapTarget = () => {
            if (!state.running || hit) return;
            hit = true;
            clearTimeout(timeout);
            state.score += 10;
            renderHUD(state);
            showMessage(state, `Nice shot! ${state.score} points.`, 550);
            target.remove();
          };
          target.addEventListener('click', tapTarget, { once: true });

          state.stageEl.appendChild(target);
        };

        const spawnTimer = setInterval(spawnTarget, 650);
        state.cleanups.push(() => clearInterval(spawnTimer));

        const spawnNow = setTimeout(() => {
          const repeat = setInterval(spawnTarget, 650);
          state.cleanups.push(() => clearInterval(repeat));
          spawnTarget();
        }, 220);
        state.cleanups.push(() => clearTimeout(spawnNow));

        for (let i = 0; i < 4; i += 1) {
          const starter = setTimeout(spawnTarget, 300 + i * 140);
          state.cleanups.push(() => clearTimeout(starter));
        }
        countdown(state);
        state.cleanups.push(() => {});
      };
      const runPuzzlePrism = (state) => {
        const colors = ['#ff5a5f', '#1fc9ff', '#ffd23a', '#b8ff3d'];
        const buttons = [];
        const prismWrap = document.createElement('div');
        prismWrap.className = 'prism-board-p2s8j4';
        state.stageEl.appendChild(prismWrap);

        let waitingInput = false;
        let pointer = 0;
        state.sequence = [Math.floor(Math.random() * colors.length)];

        const flash = (idx) => {
          const btn = buttons[idx];
          if (!btn) return;
          btn.classList.add('active');
          const light = setTimeout(() => {
            btn.classList.remove('active');
          }, 280);
          state.cleanups.push(() => clearTimeout(light));
        };

        const nextRound = () => {
          if (!state.running) return;
          waitingInput = false;
          pointer = 0;
          state.sequence.push(Math.floor(Math.random() * colors.length));
          state.sequence.forEach((idx, i) => {
            const reveal = setTimeout(() => {
              if (state.running) flash(idx);
            }, i * 650 + 180);
            state.cleanups.push(() => clearTimeout(reveal));
          });
          const open = setTimeout(() => {
            if (!state.running) return;
            waitingInput = true;
            setMessage('Repeat the pattern now.');
          }, state.sequence.length * 650 + 300);
          state.cleanups.push(() => clearTimeout(open));
        };

        const onPress = (idx) => {
          if (!state.running || !waitingInput) {
            return;
          }
          flash(idx);
          if (idx === state.sequence[pointer]) {
            pointer += 1;
            if (pointer === state.sequence.length) {
              waitingInput = false;
              state.score += 12 + (state.sequence.length * 3);
              state.timeLeft = Math.min(state.timeLeft + 1, state.timeLimit);
              renderHUD(state);
              showMessage(state, 'Pattern correct. Moving forward.', 800);
              const next = setTimeout(nextRound, 850);
              state.cleanups.push(() => clearTimeout(next));
            }
            return;
          }

          waitingInput = false;
          state.lives -= 1;
          renderHUD(state);
          showMessage(state, `Wrong order. Lives left: ${state.lives}`, 1000);
          if (state.lives <= 0) {
            finishGame(state, 'Puzzle Prism ended. No lives left.');
            return;
          }
          state.sequence = [Math.floor(Math.random() * colors.length)];
          const retry = setTimeout(nextRound, 850);
          state.cleanups.push(() => clearTimeout(retry));
        };

        colors.forEach((color, idx) => {
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.className = 'prism-btn-p2s8j4';
          btn.style.background = color;
          btn.setAttribute('aria-label', `Prism button ${idx + 1}`);
          btn.addEventListener('click', () => onPress(idx));
          prismWrap.appendChild(btn);
          buttons.push(btn);
        });

        countdown(state);
        const starter = setTimeout(nextRound, 300);
        state.cleanups.push(() => clearTimeout(starter));
      };
      const runTreasureOrbit = (state) => {
        const spawnTreasure = () => {
          if (!state.running) return;
          const boardRect = state.stageEl.getBoundingClientRect();
          const target = document.createElement('button');
          const size = 44;
          const left = Math.max(0, Math.random() * Math.max(0, boardRect.width - size));
          const top = Math.max(0, Math.random() * Math.max(0, boardRect.height - size));
          const lifeTime = 1000 + Math.floor(Math.random() * 1200);

          target.type = 'button';
          target.className = 'treasure-orb-p2s8j4';
          target.textContent = '✦';
          target.style.left = `${left}px`;
          target.style.top = `${top}px`;
          target.style.pointerEvents = 'auto';

          let cleared = false;
          const vanish = setTimeout(() => {
            if (!state.running || cleared) return;
            cleared = true;
            target.remove();
            state.lives -= 1;
            renderHUD(state);
            showMessage(state, `Treasure missed. Lives ${state.lives}.`, 850);
            if (state.lives <= 0) {
              finishGame(state, 'Treasure Orbit ended. No lives left.');
            }
          }, lifeTime);
          state.cleanups.push(() => clearTimeout(vanish));

          target.addEventListener('click', () => {
            if (!state.running || cleared) return;
            cleared = true;
            clearTimeout(vanish);
            state.score += 20;
            renderHUD(state);
            showMessage(state, `Collected. Score ${state.score}.`, 450);
            target.remove();
          }, { once: true });
          state.stageEl.appendChild(target);
        };

        const spawnTimer = setInterval(() => {
          spawnTreasure();
        }, 620);
        state.cleanups.push(() => clearInterval(spawnTimer));
        const starter = setTimeout(spawnTreasure, 250);
        state.cleanups.push(() => clearTimeout(starter));
        countdown(state);
      };
      const runPixelDrift = (state) => {
        const lanes = 5;
        const laneWidth = Math.max(44, state.stageEl.clientWidth / lanes);
        const board = document.createElement('div');
        board.className = 'drift-stage-p2s8j4';
        state.stageEl.appendChild(board);

        let lane = 2;
        const player = document.createElement('div');
        player.className = 'drift-player-p2s8j4';
        board.appendChild(player);

        const obstacles = [];
        const boardRect = board.getBoundingClientRect();
        const playerY = Math.max(14, boardRect.height - 52);

        const placePlayer = () => {
          const boardWidth = board.clientWidth || 360;
          const center = (boardWidth / lanes) * lane + ((boardWidth / lanes) - 36) / 2;
          player.style.left = `${center}px`;
        };
        const shiftLane = (step) => {
          const next = Math.max(0, Math.min(lanes - 1, lane + step));
          if (next !== lane) {
            lane = next;
            placePlayer();
          }
        };

        const onPointer = (event) => {
          if (!state.running) return;
          const box = board.getBoundingClientRect();
          const x = event.clientX - box.left;
          if (x < box.width / 2) {
            shiftLane(-1);
          } else {
            shiftLane(1);
          }
        };
        const onKey = (event) => {
          if (!state.running) return;
          if (event.key === 'ArrowLeft') {
            shiftLane(-1);
          } else if (event.key === 'ArrowRight') {
            shiftLane(1);
          }
        };

        board.addEventListener('pointerdown', onPointer);
        window.addEventListener('keydown', onKey);
        state.cleanups.push(() => board.removeEventListener('pointerdown', onPointer));
        state.cleanups.push(() => window.removeEventListener('keydown', onKey));

        placePlayer();

        const spawnObstacle = () => {
          if (!state.running) return;
          const obs = document.createElement('div');
          const obsLane = Math.floor(Math.random() * lanes);
          const height = 34;
          obs.className = 'drift-obstacle-p2s8j4';
          obs.style.left = `${obsLane * laneWidth + (laneWidth - 34) / 2}px`;
          obs.style.top = '-42px';
          obs.dataset.lane = String(obsLane);
          obs.dataset.y = '-42';
          board.appendChild(obs);
          obstacles.push(obs);
        };

        const spawner = setInterval(() => {
          spawnObstacle();
          if (!state.running) return;
        }, 650);
        state.cleanups.push(() => clearInterval(spawner));
        state.cleanups.push(() => {
          obstacles.forEach((obs) => obs.remove());
          obstacles.length = 0;
        });

        const speed = 2 + Math.min(3, Math.floor(state.timeLimit / 30));
        let rafId = null;
        const loop = () => {
          if (!state.running) return;
          const h = board.clientHeight || 0;
          const remaining = [];
          obstacles.forEach((obstacle) => {
            const currentTop = parseFloat(obstacle.dataset.y || '0');
            const nextTop = currentTop + speed;
            obstacle.dataset.y = String(nextTop);
            obstacle.style.top = `${nextTop}px`;
            const obstacleLane = Number(obstacle.dataset.lane);
            if (obstacleLane === lane && nextTop > playerY - 10 && nextTop < playerY + 24) {
              obstacle.remove();
              state.lives -= 1;
              renderHUD(state);
              showMessage(state, `Collision. Lives ${state.lives}.`, 850);
              if (state.lives <= 0) {
                finishGame(state, 'Pixel Drift ended. No lives left.');
              }
              return;
            }
            if (nextTop > h + 20) {
              obstacle.remove();
              state.score += 5;
              renderHUD(state);
              return;
            }
            remaining.push(obstacle);
          });
          obstacles.length = 0;
          obstacles.push(...remaining);

          rafId = requestAnimationFrame(loop);
        };
        state.cleanups.push(() => {
          if (rafId) {
            cancelAnimationFrame(rafId);
          }
        });

        loop();
        countdown(state);
        spawnObstacle();
      };
      const startActiveGame = () => {
        if (!currentGame) return;
        clearState(currentState);
        const state = {
          game: currentGame,
          running: true,
          stageEl: stageEl,
          score: 0,
          lives: currentGame.lives || 3,
          timeLimit: currentGame.timeLimit || 40,
          cleanups: []
        };

        if (stageEl) {
          stageEl.innerHTML = '';
        }

        currentState = state;
        if (statusEl) {
          statusEl.textContent = `${currentGame.name} is live. Stay focused.`;
        }
        renderHUD(currentState);
        setMessage(`Starting ${currentGame.name}.`);

        if (currentGame.id === 'neon-dash') {
          runNeonDash(state);
        } else if (currentGame.id === 'puzzle-prism') {
          runPuzzlePrism(state);
        } else if (currentGame.id === 'treasure-orbit') {
          runTreasureOrbit(state);
        } else if (currentGame.id === 'pixel-drift') {
          runPixelDrift(state);
        }
        if (startBtn) {
          startBtn.textContent = 'Restart game';
        }
      };

      let currentState = null;
      const pickRandom = () => gameList[Math.floor(Math.random() * gameList.length)];
      const param = new URLSearchParams(window.location.search).get('game');
      let currentGame = getGameById(param) || gameList[0];

      setGame(currentGame);

      if (startBtn) {
        startBtn.addEventListener('click', () => {
          startActiveGame();
        });
      }

      if (randomBtn) {
        randomBtn.addEventListener('click', () => {
          let next = pickRandom();
          if (gameList.length > 1) {
            while (next.id === currentGame.id) {
              next = pickRandom();
            }
          }
          setGame(next);
          clearState(currentState);
          currentState = null;
          if (startBtn) {
            startBtn.textContent = 'Start game';
          }
        });
      }
    })();
  </script>
</body>
</html>



